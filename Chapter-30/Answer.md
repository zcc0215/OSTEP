1. ```  
   NF             P0 C0 
   0 [*---  --- ]    c0
   0 [*---  --- ] p0
   0 [*---  --- ]    c1
   0 [*---  --- ]    c2
   0 [*---  --- ] p1
   1 [u  0 f--- ] p4
   1 [u  0 f--- ] p5
   1 [u  0 f--- ] p6
   1 [u  0 f--- ]    c3
   1 [u  0 f--- ] p0
   0 [ --- *--- ]    c4
   0 [ --- *--- ]    c5
   0 [ --- *--- ]    c6
   0 [ --- *--- ] p1
   0 [ --- *--- ]    c0
   1 [f--- u  1 ] p4
   1 [f--- u  1 ] p5
   1 [f--- u  1 ] p6
   1 [f--- u  1 ]    c1
   1 [f--- u  1 ] p0
   0 [*---  --- ]    c4
   0 [*---  --- ]    c5
   0 [*---  --- ]    c6
   0 [*---  --- ] p1
   0 [*---  --- ]    c0
   1 [u  2 f--- ] p4
   1 [u  2 f--- ] p5
   1 [u  2 f--- ] p6
   1 [u  2 f--- ]    c1
   0 [ --- *--- ]    c4
   0 [ --- *--- ]    c5
   0 [ --- *--- ]    c6
   1 [f--- uEOS ] [main: added end-of-stream marker]
   1 [f--- uEOS ]    c0
   1 [f--- uEOS ]    c1
   0 [*---  --- ]    c4
   0 [*---  --- ]    c5
   0 [*---  --- ]    c6

   Consumer consumption:
   C0 -> 3
2. ```
   $ ./main-two-cvs-while -p 1 -c 1 -m 1 -v
   $ ./main-two-cvs-while -p 1 -c 1 -m 10 -v
   $ ./main-two-cvs-while -p 1 -c 1 -m 1 -l 100 -v
   $ ./main-two-cvs-while -p 1 -c 1 -m 1 -C 0,0,0,0,0,0,1 -v
   $ ./main-two-cvs-while -p 1 -c 1 -m 10 -l 10 -C 0,0,0,0,0,0,1 -v
3. Linux在生产者和消费者之间的切换更加频繁
4. ./main-two-cvs-while -p 1 -c 3 -m 1 -C 0,0,0,1,0,0,0:0,0,0,1,0,0,0:0,0,0,1,0,0,0 -l 10 -v -t   
11s
5. 11s
6. 5s
7. 5s
8. 一个消费者一个生产者不会出现问题
9.  ```
    即使不配置睡眠字符串，也可能出现如下情况:
    生产者生产后，缓冲区满了，唤醒了两个正在睡眠的消费者中的一个，然后进入睡眠（Mutex_lock）
    消费者消费后，唤醒另一个消费者，进入睡眠（Mutex_lock），
    新的消费者线程被唤醒，发现缓冲区为空，进入睡眠（Cond_wait）,此时三个线程都进入睡眠

    无法配置睡眠字符串，使得代码运行必定出现问题，取决与操作系统的线程调度
10. ```
    一个消费者一个生产者不会出现问题
    出现问题的情况：
    一个生产者，两个消费者
    生产者生产完成时，消费者 c1 还没有进入临界区，消费者 c2 在 Cond_wait 处等待，
    生产者唤醒一个消费者，c1 抢先执行，执行完后缓冲区为空，c2 开始执行，发现缓冲区为空，do_get 执行发生错误！

    ./main-two-cvs-if -m 1 -c 2 -p 1 -l 10 -C 2:0,0,0,3 -P 1 会出现错误
11. $ ./main-two-cvs-while-extra-unlock -p 1 -c 2 -m 10 -l 10 -v -C 0,0,0,0,1,0,0:0,0,0,0,0,0,0  
    第一个消费者只消费一个值。